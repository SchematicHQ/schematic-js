/* tslint:disable */
/* eslint-disable */
/**
 * Schematic API
 * Schematic API
 *
 * The version of the OpenAPI document: 0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { mapValues } from "../runtime";
import type { FeatureDetailResponseData } from "./FeatureDetailResponseData";
import {
  FeatureDetailResponseDataFromJSON,
  FeatureDetailResponseDataFromJSONTyped,
  FeatureDetailResponseDataToJSON,
} from "./FeatureDetailResponseData";
import type { CompanyOverrideResponseData } from "./CompanyOverrideResponseData";
import {
  CompanyOverrideResponseDataFromJSON,
  CompanyOverrideResponseDataFromJSONTyped,
  CompanyOverrideResponseDataToJSON,
} from "./CompanyOverrideResponseData";
import type { PlanEntitlementResponseData } from "./PlanEntitlementResponseData";
import {
  PlanEntitlementResponseDataFromJSON,
  PlanEntitlementResponseDataFromJSONTyped,
  PlanEntitlementResponseDataToJSON,
} from "./PlanEntitlementResponseData";
import type { CreditGrantDetail } from "./CreditGrantDetail";
import {
  CreditGrantDetailFromJSON,
  CreditGrantDetailFromJSONTyped,
  CreditGrantDetailToJSON,
} from "./CreditGrantDetail";
import type { BillingPriceView } from "./BillingPriceView";
import {
  BillingPriceViewFromJSON,
  BillingPriceViewFromJSONTyped,
  BillingPriceViewToJSON,
} from "./BillingPriceView";
import type { PlanResponseData } from "./PlanResponseData";
import {
  PlanResponseDataFromJSON,
  PlanResponseDataFromJSONTyped,
  PlanResponseDataToJSON,
} from "./PlanResponseData";

/**
 *
 * @export
 * @interface FeatureUsageResponseData
 */
export interface FeatureUsageResponseData {
  /**
   * Whether further usage is permitted.
   * @type {boolean}
   * @memberof FeatureUsageResponseData
   */
  access: boolean;
  /**
   * The maximum amount of usage that is permitted; a null value indicates that unlimited usage is permitted.
   * @type {number}
   * @memberof FeatureUsageResponseData
   */
  allocation?: number | null;
  /**
   * The type of allocation that is being used.
   * @type {string}
   * @memberof FeatureUsageResponseData
   */
  allocationType: FeatureUsageResponseDataAllocationTypeEnum;
  /**
   *
   * @type {CompanyOverrideResponseData}
   * @memberof FeatureUsageResponseData
   */
  companyOverride?: CompanyOverrideResponseData;
  /**
   * The rate at which credits are consumed per unit of usage
   * @type {number}
   * @memberof FeatureUsageResponseData
   */
  creditConsumptionRate?: number | null;
  /**
   *
   * @type {{ [key: string]: number; }}
   * @memberof FeatureUsageResponseData
   */
  creditGrantCounts?: { [key: string]: number };
  /**
   *
   * @type {Array<CreditGrantDetail>}
   * @memberof FeatureUsageResponseData
   */
  creditGrantDetails?: Array<CreditGrantDetail>;
  /**
   * Reason for the credit grant
   * @type {string}
   * @memberof FeatureUsageResponseData
   */
  creditGrantReason?: FeatureUsageResponseDataCreditGrantReasonEnum | null;
  /**
   *
   * @type {number}
   * @memberof FeatureUsageResponseData
   */
  creditRemaining?: number | null;
  /**
   *
   * @type {number}
   * @memberof FeatureUsageResponseData
   */
  creditTotal?: number | null;
  /**
   * Icon identifier for the credit type
   * @type {string}
   * @memberof FeatureUsageResponseData
   */
  creditTypeIcon?: string | null;
  /**
   *
   * @type {number}
   * @memberof FeatureUsageResponseData
   */
  creditUsed?: number | null;
  /**
   * Effective limit for usage calculations. For overage pricing, this is the soft limit where overage charges begin. For tiered pricing, this is the first tier boundary. For other pricing models, this is the base allocation. Used to calculate usage percentages and determine access thresholds.
   * @type {number}
   * @memberof FeatureUsageResponseData
   */
  effectiveLimit?: number | null;
  /**
   * Per-unit price for current usage scenario
   * @type {number}
   * @memberof FeatureUsageResponseData
   */
  effectivePrice?: number | null;
  /**
   *
   * @type {Date}
   * @memberof FeatureUsageResponseData
   */
  entitlementExpirationDate?: Date | null;
  /**
   *
   * @type {string}
   * @memberof FeatureUsageResponseData
   */
  entitlementId: string;
  /**
   * Source of the entitlement (plan or company_override)
   * @type {string}
   * @memberof FeatureUsageResponseData
   */
  entitlementSource?: string | null;
  /**
   *
   * @type {string}
   * @memberof FeatureUsageResponseData
   */
  entitlementType: string;
  /**
   *
   * @type {FeatureDetailResponseData}
   * @memberof FeatureUsageResponseData
   */
  feature?: FeatureDetailResponseData;
  /**
   * Whether a valid allocation exists
   * @type {boolean}
   * @memberof FeatureUsageResponseData
   */
  hasValidAllocation?: boolean | null;
  /**
   * Whether this is an unlimited allocation
   * @type {boolean}
   * @memberof FeatureUsageResponseData
   */
  isUnlimited?: boolean | null;
  /**
   * The time at which the metric will reset.
   * @type {Date}
   * @memberof FeatureUsageResponseData
   */
  metricResetAt?: Date | null;
  /**
   * If the period is current_month, when the month resets.
   * @type {string}
   * @memberof FeatureUsageResponseData
   */
  monthReset?: string | null;
  /**
   *
   * @type {BillingPriceView}
   * @memberof FeatureUsageResponseData
   */
  monthlyUsageBasedPrice?: BillingPriceView;
  /**
   * Amount of usage exceeding soft limit (overage pricing only)
   * @type {number}
   * @memberof FeatureUsageResponseData
   */
  overuse?: number | null;
  /**
   * Percentage of allocation consumed (0-100+)
   * @type {number}
   * @memberof FeatureUsageResponseData
   */
  percentUsed?: number | null;
  /**
   * The period over which usage is measured.
   * @type {string}
   * @memberof FeatureUsageResponseData
   */
  period?: string | null;
  /**
   *
   * @type {PlanResponseData}
   * @memberof FeatureUsageResponseData
   */
  plan?: PlanResponseData;
  /**
   *
   * @type {PlanEntitlementResponseData}
   * @memberof FeatureUsageResponseData
   */
  planEntitlement?: PlanEntitlementResponseData;
  /**
   *
   * @type {string}
   * @memberof FeatureUsageResponseData
   */
  priceBehavior?: string | null;
  /**
   * The soft limit for the feature usage. Available only for overage price behavior
   * @type {number}
   * @memberof FeatureUsageResponseData
   */
  softLimit?: number | null;
  /**
   * The amount of usage that has been consumed; a null value indicates that usage is not being measured.
   * @type {number}
   * @memberof FeatureUsageResponseData
   */
  usage?: number | null;
  /**
   *
   * @type {BillingPriceView}
   * @memberof FeatureUsageResponseData
   */
  yearlyUsageBasedPrice?: BillingPriceView;
}

/**
 * @export
 */
export const FeatureUsageResponseDataAllocationTypeEnum = {
  Boolean: "boolean",
  Numeric: "numeric",
  Trait: "trait",
  Unlimited: "unlimited",
} as const;
export type FeatureUsageResponseDataAllocationTypeEnum =
  (typeof FeatureUsageResponseDataAllocationTypeEnum)[keyof typeof FeatureUsageResponseDataAllocationTypeEnum];

/**
 * @export
 */
export const FeatureUsageResponseDataCreditGrantReasonEnum = {
  Free: "free",
  Plan: "plan",
  Purchased: "purchased",
} as const;
export type FeatureUsageResponseDataCreditGrantReasonEnum =
  (typeof FeatureUsageResponseDataCreditGrantReasonEnum)[keyof typeof FeatureUsageResponseDataCreditGrantReasonEnum];

/**
 * Check if a given object implements the FeatureUsageResponseData interface.
 */
export function instanceOfFeatureUsageResponseData(
  value: object,
): value is FeatureUsageResponseData {
  if (!("access" in value) || value["access"] === undefined) return false;
  if (!("allocationType" in value) || value["allocationType"] === undefined)
    return false;
  if (!("entitlementId" in value) || value["entitlementId"] === undefined)
    return false;
  if (!("entitlementType" in value) || value["entitlementType"] === undefined)
    return false;
  return true;
}

export function FeatureUsageResponseDataFromJSON(
  json: any,
): FeatureUsageResponseData {
  return FeatureUsageResponseDataFromJSONTyped(json, false);
}

export function FeatureUsageResponseDataFromJSONTyped(
  json: any,
  ignoreDiscriminator: boolean,
): FeatureUsageResponseData {
  if (json == null) {
    return json;
  }
  return {
    access: json["access"],
    allocation: json["allocation"] == null ? undefined : json["allocation"],
    allocationType: json["allocation_type"],
    companyOverride:
      json["company_override"] == null
        ? undefined
        : CompanyOverrideResponseDataFromJSON(json["company_override"]),
    creditConsumptionRate:
      json["credit_consumption_rate"] == null
        ? undefined
        : json["credit_consumption_rate"],
    creditGrantCounts:
      json["credit_grant_counts"] == null
        ? undefined
        : json["credit_grant_counts"],
    creditGrantDetails:
      json["credit_grant_details"] == null
        ? undefined
        : (json["credit_grant_details"] as Array<any>).map(
            CreditGrantDetailFromJSON,
          ),
    creditGrantReason:
      json["credit_grant_reason"] == null
        ? undefined
        : json["credit_grant_reason"],
    creditRemaining:
      json["credit_remaining"] == null ? undefined : json["credit_remaining"],
    creditTotal:
      json["credit_total"] == null ? undefined : json["credit_total"],
    creditTypeIcon:
      json["credit_type_icon"] == null ? undefined : json["credit_type_icon"],
    creditUsed: json["credit_used"] == null ? undefined : json["credit_used"],
    effectiveLimit:
      json["effective_limit"] == null ? undefined : json["effective_limit"],
    effectivePrice:
      json["effective_price"] == null ? undefined : json["effective_price"],
    entitlementExpirationDate:
      json["entitlement_expiration_date"] == null
        ? undefined
        : new Date(json["entitlement_expiration_date"]),
    entitlementId: json["entitlement_id"],
    entitlementSource:
      json["entitlement_source"] == null
        ? undefined
        : json["entitlement_source"],
    entitlementType: json["entitlement_type"],
    feature:
      json["feature"] == null
        ? undefined
        : FeatureDetailResponseDataFromJSON(json["feature"]),
    hasValidAllocation:
      json["has_valid_allocation"] == null
        ? undefined
        : json["has_valid_allocation"],
    isUnlimited:
      json["is_unlimited"] == null ? undefined : json["is_unlimited"],
    metricResetAt:
      json["metric_reset_at"] == null
        ? undefined
        : new Date(json["metric_reset_at"]),
    monthReset: json["month_reset"] == null ? undefined : json["month_reset"],
    monthlyUsageBasedPrice:
      json["monthly_usage_based_price"] == null
        ? undefined
        : BillingPriceViewFromJSON(json["monthly_usage_based_price"]),
    overuse: json["overuse"] == null ? undefined : json["overuse"],
    percentUsed:
      json["percent_used"] == null ? undefined : json["percent_used"],
    period: json["period"] == null ? undefined : json["period"],
    plan:
      json["plan"] == null ? undefined : PlanResponseDataFromJSON(json["plan"]),
    planEntitlement:
      json["plan_entitlement"] == null
        ? undefined
        : PlanEntitlementResponseDataFromJSON(json["plan_entitlement"]),
    priceBehavior:
      json["price_behavior"] == null ? undefined : json["price_behavior"],
    softLimit: json["soft_limit"] == null ? undefined : json["soft_limit"],
    usage: json["usage"] == null ? undefined : json["usage"],
    yearlyUsageBasedPrice:
      json["yearly_usage_based_price"] == null
        ? undefined
        : BillingPriceViewFromJSON(json["yearly_usage_based_price"]),
  };
}

export function FeatureUsageResponseDataToJSON(
  value?: FeatureUsageResponseData | null,
): any {
  if (value == null) {
    return value;
  }
  return {
    access: value["access"],
    allocation: value["allocation"],
    allocation_type: value["allocationType"],
    company_override: CompanyOverrideResponseDataToJSON(
      value["companyOverride"],
    ),
    credit_consumption_rate: value["creditConsumptionRate"],
    credit_grant_counts: value["creditGrantCounts"],
    credit_grant_details:
      value["creditGrantDetails"] == null
        ? undefined
        : (value["creditGrantDetails"] as Array<any>).map(
            CreditGrantDetailToJSON,
          ),
    credit_grant_reason: value["creditGrantReason"],
    credit_remaining: value["creditRemaining"],
    credit_total: value["creditTotal"],
    credit_type_icon: value["creditTypeIcon"],
    credit_used: value["creditUsed"],
    effective_limit: value["effectiveLimit"],
    effective_price: value["effectivePrice"],
    entitlement_expiration_date:
      value["entitlementExpirationDate"] == null
        ? undefined
        : (value["entitlementExpirationDate"] as any).toISOString(),
    entitlement_id: value["entitlementId"],
    entitlement_source: value["entitlementSource"],
    entitlement_type: value["entitlementType"],
    feature: FeatureDetailResponseDataToJSON(value["feature"]),
    has_valid_allocation: value["hasValidAllocation"],
    is_unlimited: value["isUnlimited"],
    metric_reset_at:
      value["metricResetAt"] == null
        ? undefined
        : (value["metricResetAt"] as any).toISOString(),
    month_reset: value["monthReset"],
    monthly_usage_based_price: BillingPriceViewToJSON(
      value["monthlyUsageBasedPrice"],
    ),
    overuse: value["overuse"],
    percent_used: value["percentUsed"],
    period: value["period"],
    plan: PlanResponseDataToJSON(value["plan"]),
    plan_entitlement: PlanEntitlementResponseDataToJSON(
      value["planEntitlement"],
    ),
    price_behavior: value["priceBehavior"],
    soft_limit: value["softLimit"],
    usage: value["usage"],
    yearly_usage_based_price: BillingPriceViewToJSON(
      value["yearlyUsageBasedPrice"],
    ),
  };
}
